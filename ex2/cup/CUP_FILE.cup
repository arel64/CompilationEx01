/*************/
/* IMPORT(S) */
/*************/
import java_cup.runtime.*;
import AST.*;

parser code 
{:
	public Lexer lexer;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}
	public void report_error(String message, Object info)
	{
		System.out.print("ERROR >> ");		
		System.out.print("[");
		System.out.print(lexer.getLine());
		System.out.print(":");
		System.out.print(lexer.getCharPos());
		System.out.print("] ");		
		System.exit(0);
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
	s = lexer.next_token();
	//System.out.print(s.sym);
	System.out.print("[");
	System.out.print(lexer.getLine());
	System.out.print(":");
	System.out.print(lexer.getCharPos());
	System.out.print("] ");
	System.out.print(TokenNames.terminalNames[s.sym]);
	if (s.value != null)
	{
		System.out.print("( ");
		System.out.print(s.value);
		System.out.print(" )");
	}
	System.out.print("\n");
	return s; 
:};

/*************/
/* TERMINALS */
/*************/
terminal Integer INT;
terminal String ID;
terminal IF;
terminal EQ;
terminal DOT;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal WHILE;
terminal DIVIDE;
terminal LPAREN;
terminal RPAREN;
terminal LBRACK;
terminal RBRACK;
terminal LBRACE;
terminal RBRACE;
terminal SEMICOLON;
terminal ASSIGN;
terminal COMMA;
terminal LT;
terminal GT;
terminal NIL;
terminal ARRAY;
terminal CLASS;
terminal EXTENDS;
terminal RETURN;
terminal NEW;
terminal TYPE_VOID;
terminal TYPE_INT;
terminal TYPE_STRING;
terminal STRING;

/*****************/
/* NON TERMINALS */
/*****************/
non terminal AST_PROGRAM program;
non terminal AST_DEC dec;
non terminal AST_TYPE type;
non terminal AST_VAR_DEC varDec;
non terminal AST_FUNC_DEC funcDec;
non terminal AST_CLASS_DEC classDec;
non terminal AST_ARRAY_TYPEDEF arrayTypedef;
non terminal AST_EXP exp;
non terminal AST_VAR var;
non terminal AST_STMT stmt;
non terminal AST_NEW_EXP newExp;
non terminal AST_CFIELD cField;
non terminal AST_BINOP binop;


/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
precedence left DOT;          // Highest precedence: Field access (.)
precedence left LPAREN;       // Function call
precedence left LBRACK;     // Array indexing
precedence left TIMES, DIVIDE; // Multiplication and division
precedence left PLUS, MINUS;  // Addition and subtraction
precedence left LT, GT;       // Less-than, greater-than
precedence left EQ;       // Equals operator
precedence left ASSIGN;       // Lowest precedence: Assignment


/************************/
/* START WITH: program */
/************************/
start with program;

/********************/
/* DERIVATION RULES */
/********************/


program ::= dec+ {: RESULT = new AST_PROGRAM($1) ; :};  //a list of declarations

binop ::= PLUS  {:RESULT = new AST_BINOP("+"); :}  
 		| MINUS {:RESULT = new AST_BINOP("-"); :}
		| TIMES {:RESULT = new AST_BINOP("*"); :}
		| DIVIDE {:RESULT = new AST_BINOP("/"); :}
		| LT {:RESULT = new AST_BINOP("<"); :}
		| GT {:RESULT = new AST_BINOP(">"); :}
		| EQ {:RESULT = new AST_BINOP("="); :};

type  ::=  TYPE_INT {:RESULT = new AST_TYPE("int"); :}
		 | TYPE_STRING {:RESULT = new AST_TYPE("String"); :}
		 | TYPE_VOID {:RESULT = new AST_TYPE("void"); :}
		 | ID {: RESULT = new AST_TYPE($1); :};

arrayTypedef ::= ARRAY ID EQ type LBRACK RBRACK SEMICOLON {: RESULT = new AST_ARRAY_TYPEDEF($2, $4); :};

varDec ::= type ID ASSIGN exp SEMICOLON
    {: RESULT = new AST_VAR_DEC($2, $1, $4); :}  // Regular assignment with expression
    | type ID ASSIGN newExp SEMICOLON
    {: RESULT = new AST_VAR_DEC($2, $1, $4); :}  // Assignment with new expression
    | type ID SEMICOLON
    {: RESULT = new AST_VAR_DEC($2, $1); :};  // No assignment


funcDec ::= type ID LPAREN (type ID (COMMA type ID)*)? RPAREN LBRACE stmt (stmt)* RBRACE
    {: 
        RESULT = new AST_FUNC_DEC($2, $1, $4, $7); 
		// $2 = function name, $1 = return type, $4 = params, $7 = statements
    :};

classDec ::= CLASS ID (EXTENDS ID)? LBRACE cField (cField)* RBRACE
    {: 
        RESULT = new AST_CLASS_DEC($2, $3, $5); 
        // $2 = class name, $3 = optional parent class, $5 = fields
    :};

dec ::= varDec {: RESULT = $1; :}
     | funcDec {: RESULT = $1; :}
     | classDec {: RESULT = $1; :}
     | arrayTypedef {: RESULT = $1; :};

cField ::= varDec {: RESULT = $1; :}
		| funcDec {: RESULT = $1; :};

newExp ::= NEW type {: RESULT = AST_NEW_EXP($1); :}
		| NEW type LBRACK exp RBRACK {: RESULT = new AST_NEW_EXP($1, $2);:};

var	::=		ID {: RESULT = new AST_VAR_SIMPLE($1); :}
			| var:v DOT ID:fieldName {: RESULT = new AST_VAR_FIELD(v,fieldName); :} 
			| var:v LBRACK exp:e RBRACK	{: RESULT = new AST_VAR_SUBSCRIPT(v,e); :};

exp ::= var {: RESULT = $1; :}
		| LPAREN exp RPAREN {: RESULT = new AST_EXP($2); :}
		| exp binop exp {: RESULT = new AST_EXP_BINOP($1, $2, $3); :}
		| (var DOT)? ID LPAREN (exp (COMMA exp)*)? RPAREN {: RESULT = new AST_FUNC_INVO($2, $3, $1); :}
		| (MINUS)? INT {: RESULT = new AST_LIT_NUMBER($1, $2);:};
		| NIL  {: RESULT = new AST_LIT_STRING("NIL"); :}
		| STRING  {: RESULT = new AST_LIT_STRING($1); :}

stmt ::= varDec {: RESULT = $1; :}
    	| var ASSIGN exp SEMICOLON {: RESULT = new AST_STMT_ASSIGN($1, $3); :}
    	| var ASSIGN newExp SEMICOLON {: RESULT = new AST_STMT_ASSIGN_NEW($1, $3); :}
    	| RETURN exp SEMICOLON {: RESULT = new AST_STMT_RETURN($2); :}
    	| RETURN SEMICOLON {: RESULT = new AST_STMT_RETURN(null); :}
    	| IF LPAREN exp RPAREN LBRACE stmt (stmt)* RBRACE {: RESULT = new AST_STMT_IF($3, $6); :}
    	| WHILE LPAREN exp RPAREN LBRACE stmt (stmt)* RBRACE {: RESULT = new AST_STMT_WHILE($3, $6); :}
    	| var DOT ID LPAREN (exp (COMMA exp)*)? RPAREN SEMICOLON {: RESULT = new AST_FUNC_INVO($1, $3, $5); :};

		